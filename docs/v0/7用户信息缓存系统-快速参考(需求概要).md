# 用户信息缓存系统 - 快速参考

**版本**: v1.0
**更新**: 2025-10-28

本文档提供用户信息缓存系统的快速参考，包含核心概念、API 速查表和常见问题。

---

## 🎯 核心问题

**问题**: 退款名单显示 `user_id`（454881884228），但应该显示 `number`（177）

**解决方案**: 引入 Redis 缓存，避免每次生成名单都要循环调用知识星球 API

---

## 📊 系统架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                          前端应用（Vue 3）                         │
│                      显示退款名单（含 number）                      │
└───────────────────────────────┬─────────────────────────────────┘
                                │ HTTP Request
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                      后端 API（Express.js）                       │
│                                                                  │
│  ┌────────────────────┐         ┌──────────────────────┐        │
│  │  GET /api/camps    │         │  GET /api/users/:id  │        │
│  │  （训练营列表）     │         │  （查询用户信息）      │        │
│  └────────────────────┘         └──────────────────────┘        │
│                                                                  │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │           User Service（用户信息服务）                       │ │
│  │  - getUserById()         懒加载策略                         │ │
│  │  - getUserByNumber()     缓存优先                          │ │
│  │  - syncAllUsers()        批量预热                          │ │
│  └────────────┬───────────────────────┬───────────────────────┘ │
└───────────────┼───────────────────────┼─────────────────────────┘
                │                       │
        ┌───────▼────────┐      ┌───────▼────────┐
        │  Redis Cache   │      │ 知识星球 API    │
        │  （优先查询）   │      │ （缓存未命中）   │
        └────────────────┘      └────────────────┘
              缓存命中                API 调用
              响应 < 10ms           响应 ~200ms
```

---

## 🔄 数据流程图

### 场景 1: 生成退款名单（首次，无缓存）

```
1. 用户点击"生成退款名单"
   ↓
2. 调用 POST /api/camps/:checkinId/refund-list
   ↓
3. 获取打卡排行榜（知识星球 API）
   返回: [{ user_id: "454881884228", checkined_days: 7 }, ...]
   ↓
4. 循环遍历每个 user_id
   ↓
5. 调用 getUserById(user_id)
   ├─ 检查 Redis: zsxq:user:454881884228
   ├─ 未命中 ❌
   ├─ 调用知识星球 API 获取用户详情
   ├─ 返回: { user_id: "454881884228", number: 177, name: "青弦", ... }
   └─ 缓存到 Redis（TTL = 24h）
   ↓
6. 返回退款名单（含 number 字段）
   [{ user_id: "454881884228", number: 177, name: "青弦", is_qualified: true }, ...]
   ↓
7. 前端展示：星球编号 177 | 青弦 | 打卡 7 天 | ✅ 合格
```

**性能**: 100 人名单，首次 ~20 秒（每个用户 200ms）

---

### 场景 2: 生成退款名单（第二次，有缓存）

```
1. 用户再次点击"生成退款名单"
   ↓
2. 调用 POST /api/camps/:checkinId/refund-list
   ↓
3. 获取打卡排行榜（知识星球 API）
   ↓
4. 循环遍历每个 user_id
   ↓
5. 调用 getUserById(user_id)
   ├─ 检查 Redis: zsxq:user:454881884228
   ├─ 命中 ✅
   └─ 直接返回缓存数据
   ↓
6. 返回退款名单
   ↓
7. 前端展示
```

**性能**: 100 人名单，仅需 ~2 秒（缓存查询 < 10ms/人）

**性能提升**: 10 倍！（20 秒 → 2 秒）

---

### 场景 3: 批量预热缓存（管理员操作）

```
1. 管理员调用 POST /api/users/sync
   ↓
2. 获取所有用户 ID（从排行榜或其他来源）
   例如: 120 个用户
   ↓
3. 并发控制（concurrency = 5）
   ├─ 线程 1: 处理 user_id_1, user_id_6, user_id_11, ...
   ├─ 线程 2: 处理 user_id_2, user_id_7, user_id_12, ...
   ├─ 线程 3: 处理 user_id_3, user_id_8, user_id_13, ...
   ├─ 线程 4: 处理 user_id_4, user_id_9, user_id_14, ...
   └─ 线程 5: 处理 user_id_5, user_id_10, user_id_15, ...
   ↓
4. 每个请求间隔 200ms（避免限流）
   ↓
5. 缓存到 Redis
   ├─ zsxq:user:{user_id}  → Hash（用户完整信息）
   ├─ zsxq:number:{number} → String（number → user_id 映射）
   └─ zsxq:users:all       → Set（所有用户 ID）
   ↓
6. 返回同步结果
   { success_count: 118, failed_count: 2, duration_ms: 24000 }
```

**耗时**: 120 人 × 200ms ÷ 5 并发 ≈ 24 秒

---

## 📦 Redis 数据结构速查

### 结构一览

```redis
# 1. 用户信息（Hash）
zsxq:user:454881884228 → { user_id, number, name, ... }

# 2. Number 索引（String）
zsxq:number:177 → "454881884228"

# 3. 用户 ID 集合（Set）
zsxq:users:all → ["454881884228", "412451285841818", ...]

# 4. 缓存统计（Hash）
zsxq:stats:cache → { total_requests, cache_hits, cache_misses, ... }
```

### 查询示例

```bash
# 查询用户信息
redis-cli HGETALL zsxq:user:454881884228

# 根据 number 查找 user_id
redis-cli GET zsxq:number:177

# 查看所有已缓存的用户 ID
redis-cli SMEMBERS zsxq:users:all

# 查看缓存统计
redis-cli HGETALL zsxq:stats:cache

# 查看缓存命中率
redis-cli HGET zsxq:stats:cache cache_hit_rate
```

---

## 🚀 API 速查表

### 用户信息查询

| API | 方法 | 描述 | 响应时间 |
|-----|------|------|---------|
| `/api/users` | GET | 获取所有用户（分页） | ~50ms |
| `/api/users/:userId` | GET | 根据 user_id 查询 | ~10ms（缓存命中）<br>~200ms（未命中） |
| `/api/users/number/:number` | GET | 根据 number 查询 | ~10ms（缓存命中） |

### 缓存管理

| API | 方法 | 描述 | 用途 |
|-----|------|------|------|
| `/api/users/sync` | POST | 批量同步用户信息 | 管理员手动预热缓存 |
| `/api/users/cache` | DELETE | 清空缓存 | 强制刷新缓存 |
| `/api/users/cache/stats` | GET | 查看缓存统计 | 监控缓存性能 |

---

## 🛠️ 使用指南

### 开发环境启动

**1. 启动 Redis**:
```bash
# macOS (Homebrew)
brew services start redis

# Linux (SystemD)
systemctl start redis

# Docker
docker run -d -p 6379:6379 redis:7-alpine
```

**2. 配置环境变量**:
```env
# .env
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=
CACHE_TTL=86400
```

**3. 启动后端服务**:
```bash
cd zsxq-api
npm install ioredis p-limit
npm run dev
```

**4. 预热缓存（可选）**:
```bash
curl -X POST http://localhost:3013/api/users/sync \
  -H "Content-Type: application/json" \
  -d '{ "force": false, "concurrency": 5 }'
```

---

## 📝 关键配置参数

| 参数 | 默认值 | 说明 | 建议值 |
|------|-------|------|--------|
| `CACHE_TTL` | 86400 | 缓存过期时间（秒） | 24h（86400）|
| `API_CONCURRENCY` | 5 | 批量同步并发数 | 3-5（避免限流） |
| `API_REQUEST_DELAY` | 200 | 请求间隔（毫秒） | 200-500 |
| `CACHE_ENABLED` | true | 是否启用缓存 | true |

---

## ⚠️ 常见问题

### Q1: 缓存命中率低怎么办？

**原因**:
- Redis 未启动
- 缓存过期时间设置过短
- 用户 ID 频繁变化

**解决方案**:
1. 检查 Redis 连接: `redis-cli PING`
2. 增加 TTL: `CACHE_TTL=172800` (48 小时)
3. 手动预热缓存: `POST /api/users/sync`

---

### Q2: 知识星球 API 返回 429 限流

**原因**:
- 并发请求过多
- 请求间隔太短

**解决方案**:
1. 降低并发数: `API_CONCURRENCY=3`
2. 增加请求间隔: `API_REQUEST_DELAY=500`
3. 使用批量同步而非实时查询

---

### Q3: Redis 不可用时怎么办？

**自动降级**:
系统会自动降级到直接调用知识星球 API，不会影响业务功能，只是响应时间变慢。

**日志**:
```
[WARN] Redis 不可用，降级到直接调用 API
```

---

### Q4: 如何验证缓存是否生效？

**方法 1: 查看日志**:
```bash
# zsxq-api/logs/app-YYYY-MM-DD.log
[INFO] 缓存命中: user_id=454881884228, cache_status=hit
[WARN] 缓存未命中，调用 API: user_id=xxx, cache_status=miss
```

**方法 2: 查看缓存统计**:
```bash
curl http://localhost:3013/api/users/cache/stats
```

**方法 3: 对比响应时间**:
- 首次查询: ~20 秒（100 人）
- 第二次: ~2 秒（缓存命中）

---

## 📈 性能对比

| 场景 | 无缓存 | 有缓存 | 提升 |
|------|--------|--------|------|
| 生成 100 人退款名单 | 20 秒 | 2 秒 | **10 倍** |
| 生成 200 人退款名单 | 40 秒 | 4 秒 | **10 倍** |
| 单个用户查询 | 200ms | 10ms | **20 倍** |

---

## 🔧 故障排查

### Redis 连接失败

**错误信息**:
```
Error: connect ECONNREFUSED 127.0.0.1:6379
```

**解决方案**:
```bash
# 检查 Redis 是否运行
redis-cli PING
# 应该返回: PONG

# 检查端口是否被占用
lsof -i :6379

# 重启 Redis
brew services restart redis  # macOS
systemctl restart redis      # Linux
```

---

### 缓存数据不一致

**现象**: 用户信息已更新，但缓存中还是旧数据

**解决方案**:
```bash
# 方法 1: 清空缓存（推荐）
curl -X DELETE http://localhost:3013/api/users/cache

# 方法 2: 手动删除 Redis 键
redis-cli DEL zsxq:user:454881884228
redis-cli DEL zsxq:number:177

# 方法 3: 强制重新同步
curl -X POST http://localhost:3013/api/users/sync \
  -H "Content-Type: application/json" \
  -d '{ "force": true }'
```

---

## 🎯 最佳实践

1. **定时预热缓存**:
   ```bash
   # 每天凌晨 2 点自动同步
   0 2 * * * curl -X POST http://localhost:3013/api/users/sync
   ```

2. **监控缓存命中率**:
   - 目标: > 80%
   - 低于 80% 时考虑增加 TTL 或预热频率

3. **限流保护**:
   - 批量同步时间控制在非高峰期
   - 并发数不超过 5

4. **降级处理**:
   - Redis 不可用时自动降级到 API
   - 重要操作不依赖缓存

---

## 📚 相关文档

- [完整技术方案](8用户信息缓存系统技术方案.md)
- [知识星球 API 示例](../../static/dataCases/number.md)
- [Redis 命令参考](https://redis.io/commands/)

---

**文档更新**: 2025-10-28


# 知识星球用户信息缓存系统技术方案

**文档版本**: v1.0
**创建日期**: 2025-10-28
**作者**: Claude Code
**状态**: 设计阶段

---

## 1. 问题背景

### 1.1 当前问题

在退款名单生成功能中，系统显示的是知识星球用户的 `user_id`（例如：`454881884228`），但实际业务需求是显示**星球成员编号 `number`**（例如：`177`）。

**示例对比**：

| 字段 | 当前显示（错误） | 应该显示（正确） |
|------|----------------|----------------|
| 星球ID | 454881884228 (user_id) | 177 (number) |
| 数据来源 | 排行榜接口直接返回 | 需调用用户详情接口 |

### 1.2 技术挑战

1. **数据获取问题**：
   - 排行榜接口 `GET /v2/groups/{groupId}/checkins/{checkinId}/ranking_list` 只返回 `user_id`
   - 获取 `number` 需要额外调用用户详情接口 `GET /v2/groups/{groupId}/members/{userId}/summary`

2. **性能问题**：
   - 如果每次生成退款名单（假设 100 人）都循环调用 100 次用户详情接口，会导致：
     - 接口响应时间过长（每个请求 ~200ms，100 个请求 = 20 秒）
     - 知识星球 API 可能触发**限流**（Rate Limit）
     - 用户体验极差

3. **业务需求**：
   - 用户信息相对稳定（`number`、`name` 等字段不常变化）
   - 可以使用缓存策略减少 API 调用次数

---

## 2. 解决方案概述

### 2.1 核心思路

**引入 Redis 缓存用户信息**，采用"**懒加载 + 批量预热**"策略：

1. **懒加载**：首次查询时从知识星球 API 获取，然后缓存到 Redis
2. **批量预热**：提供手动同步接口，一次性获取所有用户信息并缓存
3. **自动刷新**：设置缓存过期时间（如 24 小时），过期后自动重新获取
4. **降级处理**：Redis 不可用时直接调用知识星球 API

### 2.2 技术栈

| 技术 | 用途 | 版本 |
|------|------|------|
| **Redis** | 用户信息缓存 | 7.0+ |
| **ioredis** | Node.js Redis 客户端 | ^5.3.0 |
| **axios** | HTTP 请求库（已有） | ^1.6.0 |
| **p-limit** | 并发控制（批量请求） | ^5.0.0 |

---

## 3. 数据模型设计

### 3.1 用户信息数据模型

```javascript
// TypeScript 定义（文档说明用）
interface PlanetUser {
  user_id: string;           // 知识星球用户ID（唯一标识）
  number: number;            // 星球成员编号（业务展示）
  name: string;              // 用户昵称
  unique_id: string;         // 唯一标识符（可为空）
  avatar_url: string;        // 头像URL
  join_time: string;         // 加入时间（ISO 8601）
  status: string;            // 状态（joined/left）
  expired_time: string;      // 会员过期时间
  introduction: string;      // 个人简介

  // 缓存元数据
  cached_at: number;         // 缓存时间戳（毫秒）
  updated_at: number;        // 最后更新时间戳
}
```

**示例数据**：
```json
{
  "user_id": "454881884228",
  "number": 177,
  "name": "青弦",
  "unique_id": "huangfenng",
  "avatar_url": "https://images.zsxq.com/...",
  "join_time": "2024-09-04T22:39:05.287+0800",
  "status": "joined",
  "expired_time": "2026-09-04T22:39:05.287+0800",
  "introduction": "高级前端开发工程师",
  "cached_at": 1730080000000,
  "updated_at": 1730080000000
}
```

---

## 4. Redis 数据结构设计

### 4.1 键命名规范

采用 **命名空间 + 资源类型 + 标识符** 的格式：

```
格式: zsxq:{resource_type}:{identifier}
```

**命名空间说明**：
- `zsxq` - 项目命名空间（避免与其他项目冲突）
- `user` - 资源类型（用户信息）
- `number` - 索引类型（number 到 user_id 的映射）
- `all` - 集合标识（所有用户 ID 集合）

### 4.2 数据结构设计

#### 4.2.1 用户信息存储（Hash）

**键名**: `zsxq:user:{user_id}`
**数据类型**: Hash
**用途**: 存储单个用户的完整信息
**过期时间**: 24 小时（86400 秒）

**结构**：
```redis
HSET zsxq:user:454881884228
  user_id "454881884228"
  number "177"
  name "青弦"
  unique_id "huangfenng"
  avatar_url "https://images.zsxq.com/..."
  join_time "2024-09-04T22:39:05.287+0800"
  status "joined"
  expired_time "2026-09-04T22:39:05.287+0800"
  introduction "高级前端开发工程师"
  cached_at "1730080000000"
  updated_at "1730080000000"

EXPIRE zsxq:user:454881884228 86400
```

**优势**：
- Hash 结构节省内存（相比 String 存储 JSON）
- 支持单字段更新（HSET 单个字段）
- 查询效率高（O(1) 复杂度）

#### 4.2.2 Number 索引（String）

**键名**: `zsxq:number:{number}`
**数据类型**: String
**用途**: 根据 `number` 快速查找 `user_id`
**过期时间**: 24 小时

**结构**：
```redis
SET zsxq:number:177 "454881884228"
EXPIRE zsxq:number:177 86400
```

**使用场景**：
```javascript
// 根据 number 查询用户信息
const userId = await redis.get('zsxq:number:177');
const userInfo = await redis.hgetall(`zsxq:user:${userId}`);
```

#### 4.2.3 用户ID集合（Set）

**键名**: `zsxq:users:all`
**数据类型**: Set
**用途**: 存储所有已缓存的用户 ID
**过期时间**: 24 小时

**结构**：
```redis
SADD zsxq:users:all "454881884228" "412451285841818" "15411425221212"
EXPIRE zsxq:users:all 86400
```

**使用场景**：
```javascript
// 获取所有已缓存的用户ID
const allUserIds = await redis.smembers('zsxq:users:all');

// 检查用户是否已缓存
const isCached = await redis.sismember('zsxq:users:all', '454881884228');
```

#### 4.2.4 缓存统计（Hash）

**键名**: `zsxq:stats:cache`
**数据类型**: Hash
**用途**: 记录缓存命中率、API 调用次数等统计信息
**过期时间**: 永久（手动清理）

**结构**：
```redis
HSET zsxq:stats:cache
  total_requests "1000"        # 总请求次数
  cache_hits "850"             # 缓存命中次数
  cache_misses "150"           # 缓存未命中次数
  api_calls "200"              # 知识星球 API 调用次数
  last_sync_time "1730080000000"  # 最后同步时间
```

---

## 5. API 接口设计

### 5.1 RESTful API 规范

**Base URL**: `http://localhost:3013/api`

#### 5.1.1 获取所有用户信息

**接口**: `GET /api/users`

**描述**: 分页获取所有已缓存的用户信息

**请求参数（Query）**:
```json
{
  "page": 1,           // 页码（默认: 1）
  "page_size": 50,     // 每页数量（默认: 50，最大: 200）
  "sort_by": "number", // 排序字段（number/join_time，默认: number）
  "order": "asc"       // 排序方向（asc/desc，默认: asc）
}
```

**响应示例**:
```json
{
  "code": 200,
  "message": "查询成功",
  "data": {
    "users": [
      {
        "user_id": "454881884228",
        "number": 177,
        "name": "青弦",
        "avatar_url": "https://images.zsxq.com/...",
        "join_time": "2024-09-04T22:39:05.287+0800",
        "status": "joined"
      }
    ],
    "pagination": {
      "page": 1,
      "page_size": 50,
      "total_count": 120,
      "total_pages": 3
    },
    "cache_info": {
      "total_cached": 120,
      "cache_hit_rate": 85.5,
      "last_sync_time": "2025-10-28T02:00:00.000Z"
    }
  },
  "timestamp": 1730080000000
}
```

**实现逻辑**:
```javascript
// 伪代码
async function getUsers(page, pageSize, sortBy, order) {
  // 1. 从 Redis 获取所有用户 ID
  const userIds = await redis.smembers('zsxq:users:all');

  // 2. 批量获取用户信息（使用 Redis Pipeline 优化）
  const users = await getUsersBatch(userIds);

  // 3. 排序和分页
  const sortedUsers = sortUsers(users, sortBy, order);
  const paginatedUsers = paginate(sortedUsers, page, pageSize);

  return paginatedUsers;
}
```

---

#### 5.1.2 根据 user_id 查询用户

**接口**: `GET /api/users/:userId`

**描述**: 根据知识星球 `user_id` 查询用户信息（优先从缓存获取）

**URL 参数**:
- `userId` - 知识星球用户ID（必填）

**响应示例**:
```json
{
  "code": 200,
  "message": "查询成功",
  "data": {
    "user_id": "454881884228",
    "number": 177,
    "name": "青弦",
    "unique_id": "huangfenng",
    "avatar_url": "https://images.zsxq.com/...",
    "join_time": "2024-09-04T22:39:05.287+0800",
    "status": "joined",
    "expired_time": "2026-09-04T22:39:05.287+0800",
    "introduction": "高级前端开发工程师",
    "cache_status": "hit"  // hit/miss
  },
  "timestamp": 1730080000000
}
```

**实现逻辑**（懒加载）:
```javascript
async function getUserById(userId) {
  // 1. 尝试从 Redis 获取
  const cachedUser = await redis.hgetall(`zsxq:user:${userId}`);

  if (cachedUser && cachedUser.user_id) {
    // 缓存命中
    logger.info(`缓存命中: user_id=${userId}`);
    await redis.hincrby('zsxq:stats:cache', 'cache_hits', 1);
    return { ...cachedUser, cache_status: 'hit' };
  }

  // 2. 缓存未命中，调用知识星球 API
  logger.info(`缓存未命中，调用知识星球 API: user_id=${userId}`);
  const apiUser = await zsxqService.getUserDetail(userId);

  // 3. 缓存到 Redis
  await cacheUser(apiUser);
  await redis.hincrby('zsxq:stats:cache', 'cache_misses', 1);
  await redis.hincrby('zsxq:stats:cache', 'api_calls', 1);

  return { ...apiUser, cache_status: 'miss' };
}
```

---

#### 5.1.3 根据 number 查询用户

**接口**: `GET /api/users/number/:number`

**描述**: 根据星球成员编号 `number` 查询用户信息

**URL 参数**:
- `number` - 星球成员编号（必填）

**响应示例**:
```json
{
  "code": 200,
  "message": "查询成功",
  "data": {
    "user_id": "454881884228",
    "number": 177,
    "name": "青弦",
    "cache_status": "hit"
  },
  "timestamp": 1730080000000
}
```

**实现逻辑**:
```javascript
async function getUserByNumber(number) {
  // 1. 从索引中查找 user_id
  const userId = await redis.get(`zsxq:number:${number}`);

  if (!userId) {
    throw new Error(`未找到编号为 ${number} 的用户`);
  }

  // 2. 根据 user_id 查询用户信息
  return await getUserById(userId);
}
```

---

#### 5.1.4 批量同步用户信息

**接口**: `POST /api/users/sync`

**描述**: 批量从知识星球 API 获取所有用户信息并缓存到 Redis（管理员功能）

**请求参数（Body）**:
```json
{
  "force": false,        // 是否强制刷新（默认: false，只同步未缓存的用户）
  "concurrency": 5       // 并发请求数（默认: 5，避免触发限流）
}
```

**响应示例**:
```json
{
  "code": 200,
  "message": "同步完成",
  "data": {
    "sync_count": 120,      // 本次同步的用户数
    "success_count": 118,   // 成功数
    "failed_count": 2,      // 失败数
    "skipped_count": 50,    // 跳过数（已缓存且 force=false）
    "duration_ms": 24000,   // 耗时（毫秒）
    "failed_users": [
      {
        "user_id": "xxx",
        "error": "API 超时"
      }
    ]
  },
  "timestamp": 1730080000000
}
```

**实现逻辑**（批量预热）:
```javascript
const pLimit = require('p-limit');

async function syncAllUsers(force = false, concurrency = 5) {
  // 1. 获取所有用户 ID（从排行榜接口或其他来源）
  const allUserIds = await getAllUserIdsFromZsxq();

  // 2. 过滤已缓存的用户（force=false 时）
  let userIdsToSync = allUserIds;
  if (!force) {
    const cachedUserIds = await redis.smembers('zsxq:users:all');
    userIdsToSync = allUserIds.filter(id => !cachedUserIds.includes(id));
  }

  logger.info(`开始同步用户信息: 总数=${allUserIds.length}, 待同步=${userIdsToSync.length}`);

  // 3. 并发控制（避免触发限流）
  const limit = pLimit(concurrency);
  const results = {
    success: [],
    failed: []
  };

  const tasks = userIdsToSync.map(userId =>
    limit(async () => {
      try {
        // 每个请求间隔 200ms（可配置）
        await sleep(200);

        const userInfo = await zsxqService.getUserDetail(userId);
        await cacheUser(userInfo);
        results.success.push(userId);

        logger.info(`同步成功: user_id=${userId}, number=${userInfo.number}`);
      } catch (error) {
        results.failed.push({ user_id: userId, error: error.message });
        logger.error(`同步失败: user_id=${userId}, error=${error.message}`);
      }
    })
  );

  await Promise.all(tasks);

  return {
    sync_count: userIdsToSync.length,
    success_count: results.success.length,
    failed_count: results.failed.length,
    failed_users: results.failed
  };
}
```

---

#### 5.1.5 清空用户缓存

**接口**: `DELETE /api/users/cache`

**描述**: 清空所有用户信息缓存（管理员功能）

**响应示例**:
```json
{
  "code": 200,
  "message": "缓存已清空",
  "data": {
    "deleted_keys": 125,
    "deleted_users": 120
  },
  "timestamp": 1730080000000
}
```

**实现逻辑**:
```javascript
async function clearUserCache() {
  // 1. 获取所有用户 ID
  const userIds = await redis.smembers('zsxq:users:all');

  // 2. 批量删除用户缓存
  const pipeline = redis.pipeline();

  userIds.forEach(userId => {
    pipeline.del(`zsxq:user:${userId}`);
    // 删除 number 索引需要先查询 number
  });

  pipeline.del('zsxq:users:all');
  pipeline.del('zsxq:stats:cache');

  const results = await pipeline.exec();

  logger.info(`缓存清空完成: 删除 ${results.length} 个键`);

  return {
    deleted_keys: results.length,
    deleted_users: userIds.length
  };
}
```

---

#### 5.1.6 获取缓存统计

**接口**: `GET /api/users/cache/stats`

**描述**: 获取缓存命中率、API 调用次数等统计信息

**响应示例**:
```json
{
  "code": 200,
  "message": "查询成功",
  "data": {
    "total_requests": 1000,
    "cache_hits": 850,
    "cache_misses": 150,
    "cache_hit_rate": 85.0,
    "api_calls": 200,
    "cached_users_count": 120,
    "last_sync_time": "2025-10-28T02:00:00.000Z",
    "redis_memory_usage": "2.5 MB"
  },
  "timestamp": 1730080000000
}
```

---

## 6. 服务架构设计

### 6.1 分层架构

```
┌─────────────────────────────────────────────────────┐
│                  Controller Layer                    │
│           (routes/users.js - API 路由)              │
└──────────────────────┬──────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────┐
│                  Service Layer                       │
│         (services/user.service.js - 业务逻辑)        │
│  - getUserById()                                    │
│  - getUserByNumber()                                │
│  - syncAllUsers()                                   │
│  - clearCache()                                     │
└──────────────┬───────────────────┬──────────────────┘
               │                   │
       ┌───────▼────────┐  ┌───────▼────────┐
       │  Redis Cache   │  │  Zsxq Service  │
       │  (缓存层)       │  │  (API 层)      │
       └────────────────┘  └────────────────┘
```

### 6.2 文件结构

```
zsxq-api/
├── src/
│   ├── services/
│   │   ├── zsxq.service.js       # 知识星球 API 封装（已有）
│   │   ├── user.service.js       # 用户信息服务（新增）
│   │   └── redis.service.js      # Redis 封装（新增）
│   ├── routes/
│   │   ├── camps.js              # 训练营路由（已有）
│   │   └── users.js              # 用户信息路由（新增）
│   ├── utils/
│   │   ├── redis.js              # Redis 客户端初始化（新增）
│   │   └── limiter.js            # API 限流器（新增）
│   └── config/
│       └── redis.config.js       # Redis 配置（新增）
├── .env                          # 环境变量
└── package.json
```

---

## 7. 实现流程

### 7.1 流程图

#### 7.1.1 懒加载流程（查询单个用户）

```
用户请求
   ↓
GET /api/users/:userId
   ↓
┌────────────────────────┐
│ 查询 Redis 缓存         │
│ zsxq:user:{userId}     │
└────────┬───────────────┘
         │
    ┌────▼────┐
    │ 命中？   │
    └────┬────┘
         │
    ┌────▼────┐         ┌────────────────┐
    │   是    │────────→│ 返回缓存数据    │
    └─────────┘         └────────────────┘
         │
    ┌────▼────┐
    │   否    │
    └────┬────┘
         │
┌────────▼────────────────┐
│ 调用知识星球 API         │
│ GET /members/{userId}   │
└────────┬────────────────┘
         │
┌────────▼────────────────┐
│ 缓存到 Redis            │
│ - zsxq:user:{userId}    │
│ - zsxq:number:{number}  │
│ - zsxq:users:all        │
└────────┬────────────────┘
         │
┌────────▼────────────────┐
│ 返回用户数据             │
└─────────────────────────┘
```

#### 7.1.2 批量同步流程

```
管理员触发
   ↓
POST /api/users/sync
   ↓
┌────────────────────────┐
│ 获取所有用户 ID         │
│ （从排行榜接口）         │
└────────┬───────────────┘
         │
┌────────▼────────────────┐
│ 过滤已缓存的用户（可选） │
└────────┬────────────────┘
         │
┌────────▼────────────────┐
│ 并发控制（p-limit）      │
│ concurrency = 5         │
└────────┬────────────────┘
         │
    ┌────▼────┐
    │ 循环调用 │
    └────┬────┘
         │
┌────────▼────────────────┐
│ 调用知识星球 API         │
│ 延迟 200ms（避免限流）   │
└────────┬────────────────┘
         │
┌────────▼────────────────┐
│ 缓存到 Redis            │
└────────┬────────────────┘
         │
┌────────▼────────────────┐
│ 返回同步结果统计         │
└─────────────────────────┘
```

---

## 8. 错误处理和降级策略

### 8.1 Redis 不可用

**场景**: Redis 连接失败或超时

**降级策略**:
```javascript
async function getUserById(userId) {
  try {
    // 尝试从 Redis 获取
    const cachedUser = await redis.hgetall(`zsxq:user:${userId}`);
    if (cachedUser && cachedUser.user_id) {
      return cachedUser;
    }
  } catch (redisError) {
    logger.warn(`Redis 不可用，降级到直接调用 API: ${redisError.message}`);
  }

  // Redis 失败或未命中，直接调用知识星球 API
  return await zsxqService.getUserDetail(userId);
}
```

### 8.2 知识星球 API 限流

**场景**: API 返回 429 Too Many Requests

**应对策略**:
1. **指数退避重试**:
```javascript
async function getUserDetailWithRetry(userId, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await zsxqService.getUserDetail(userId);
    } catch (error) {
      if (error.response?.status === 429) {
        const delay = Math.pow(2, i) * 1000; // 1s, 2s, 4s
        logger.warn(`API 限流，等待 ${delay}ms 后重试`);
        await sleep(delay);
      } else {
        throw error;
      }
    }
  }
  throw new Error('重试次数已用尽');
}
```

2. **请求队列**:
```javascript
const queue = [];
let isProcessing = false;

async function addToQueue(userId) {
  queue.push(userId);
  if (!isProcessing) {
    await processQueue();
  }
}

async function processQueue() {
  isProcessing = true;
  while (queue.length > 0) {
    const userId = queue.shift();
    await getUserDetail(userId);
    await sleep(200); // 固定间隔
  }
  isProcessing = false;
}
```

---

## 9. 配置和环境变量

### 9.1 Redis 配置

在 `.env` 文件中添加：

```env
# Redis 配置
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=          # 可选
REDIS_DB=0               # 数据库编号（默认: 0）

# 缓存配置
CACHE_TTL=86400          # 缓存过期时间（秒，默认: 24 小时）
CACHE_ENABLED=true       # 是否启用缓存（默认: true）

# API 限流配置
API_RATE_LIMIT=50        # 每分钟最多调用次数
API_CONCURRENCY=5        # 批量同步并发数
API_REQUEST_DELAY=200    # 请求间隔（毫秒）
```

### 9.2 代码配置

**redis.config.js**:
```javascript
module.exports = {
  redis: {
    host: process.env.REDIS_HOST || 'localhost',
    port: parseInt(process.env.REDIS_PORT) || 6379,
    password: process.env.REDIS_PASSWORD || undefined,
    db: parseInt(process.env.REDIS_DB) || 0,
    retryStrategy: (times) => {
      const delay = Math.min(times * 50, 2000);
      return delay;
    }
  },
  cache: {
    ttl: parseInt(process.env.CACHE_TTL) || 86400,
    enabled: process.env.CACHE_ENABLED !== 'false'
  },
  api: {
    rateLimit: parseInt(process.env.API_RATE_LIMIT) || 50,
    concurrency: parseInt(process.env.API_CONCURRENCY) || 5,
    requestDelay: parseInt(process.env.API_REQUEST_DELAY) || 200
  }
};
```

---

## 10. 性能优化

### 10.1 Redis Pipeline

批量操作时使用 Pipeline 减少网络往返：

```javascript
async function cacheMultipleUsers(users) {
  const pipeline = redis.pipeline();

  users.forEach(user => {
    pipeline.hset(`zsxq:user:${user.user_id}`, user);
    pipeline.set(`zsxq:number:${user.number}`, user.user_id);
    pipeline.sadd('zsxq:users:all', user.user_id);
  });

  await pipeline.exec();
}
```

### 10.2 批量查询优化

使用 `MGET` 或 Pipeline 批量查询：

```javascript
async function getUsersBatch(userIds) {
  const pipeline = redis.pipeline();

  userIds.forEach(userId => {
    pipeline.hgetall(`zsxq:user:${userId}`);
  });

  const results = await pipeline.exec();
  return results.map(([err, user]) => user);
}
```

### 10.3 内存优化

**预估内存占用**：
- 单个用户信息: ~500 字节
- 1000 个用户: ~500 KB
- 可忽略不计

**优化策略**：
- 只缓存常用字段（可选）
- 使用 Redis Hash 而非 JSON 字符串（节省 20-30% 内存）

---

## 11. 监控和告警

### 11.1 关键指标

1. **缓存命中率**:
   ```javascript
   const hitRate = (cacheHits / totalRequests) * 100;
   ```
   - 目标: > 80%

2. **API 调用次数**:
   - 监控每分钟调用次数
   - 告警阈值: > 50 次/分钟

3. **Redis 可用性**:
   - 健康检查: `PING` 命令
   - 告警: 连接失败超过 3 次

### 11.2 日志记录

```javascript
// 缓存命中
logger.info('缓存命中', { user_id, cache_status: 'hit' });

// 缓存未命中
logger.warn('缓存未命中，调用 API', { user_id, cache_status: 'miss' });

// API 限流
logger.error('知识星球 API 限流', { status: 429, retry_after: 60 });

// Redis 错误
logger.error('Redis 连接失败', { error: error.message });
```

---

## 12. 测试计划

### 12.1 单元测试

**测试用例**:
1. `getUserById()` - 缓存命中和未命中
2. `getUserByNumber()` - 正常和异常情况
3. `syncAllUsers()` - 批量同步成功和失败
4. `cacheUser()` - 缓存写入正确性

**工具**: Jest + Redis Mock

### 12.2 集成测试

**测试场景**:
1. Redis 不可用时的降级处理
2. 知识星球 API 限流时的重试逻辑
3. 并发请求的正确性

### 12.3 压力测试

**测试目标**:
- 1000 个用户并发查询，响应时间 < 200ms
- 批量同步 500 个用户，完成时间 < 2 分钟

---

## 13. 实施计划

### 13.1 开发任务分解

| 任务 | 预估时间 | 优先级 |
|------|---------|--------|
| Task 1: 安装 Redis 和 ioredis | 0.5h | P0 |
| Task 2: 编写 redis.service.js | 1.5h | P0 |
| Task 3: 编写 user.service.js | 2.5h | P0 |
| Task 4: 编写 users.js 路由 | 2h | P0 |
| Task 5: 修改 refund.service.js（使用 number） | 1h | P0 |
| Task 6: 编写单元测试 | 2h | P1 |
| Task 7: 前端适配（显示 number） | 1h | P0 |
| Task 8: 集成测试和文档 | 1.5h | P1 |
| **总计** | **12h** |  |

### 13.2 实施步骤

**阶段一：基础设施（2h）**
1. 安装 Redis（本地开发环境）
2. 安装 npm 依赖：`ioredis`、`p-limit`
3. 配置 Redis 连接和环境变量

**阶段二：核心功能（6h）**
1. 实现 `redis.service.js`（Redis 封装）
2. 实现 `user.service.js`（用户信息服务）
3. 实现 `users.js` 路由（API 接口）
4. 修改 `zsxq.service.js`（新增 `getUserDetail` 方法）

**阶段三：业务集成（2h）**
1. 修改 `refund.service.js`（退款名单使用 `number`）
2. 修改前端 `RefundList.vue`（显示 `number` 而非 `user_id`）

**阶段四：测试和文档（2h）**
1. 编写单元测试
2. 接口测试（Postman）
3. 更新 README 和 USAGE 文档

---

## 14. 风险评估

| 风险 | 可能性 | 影响 | 应对措施 |
|------|-------|------|---------|
| Redis 不可用导致服务不可用 | 中 | 高 | 实现降级策略，直接调用 API |
| 知识星球 API 限流 | 高 | 中 | 批量同步时控制并发，加入延迟 |
| 缓存数据不一致 | 低 | 中 | 设置合理的 TTL，提供手动刷新接口 |
| Redis 内存不足 | 低 | 低 | 使用 LRU 策略，设置 maxmemory |

---

## 15. 后续优化方向

1. **分布式缓存**：生产环境使用 Redis Cluster
2. **缓存预热**：定时任务自动同步用户信息
3. **缓存穿透保护**：使用布隆过滤器
4. **读写分离**：Redis 主从架构
5. **监控面板**：Grafana + Prometheus 可视化

---

## 16. 参考文档

- [知识星球 API 文档](static/dataCases/number.md)
- [ioredis 官方文档](https://github.com/redis/ioredis)
- [Redis 最佳实践](https://redis.io/docs/manual/patterns/)

---

**文档更新记录**:
- 2025-10-28: v1.0 初始版本创建


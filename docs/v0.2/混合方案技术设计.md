# v0.2 æ··åˆæ–¹æ¡ˆæŠ€æœ¯è®¾è®¡

## ğŸ“‹ ç›®å½•

- [æ–¹æ¡ˆæ¦‚è¿°](#æ–¹æ¡ˆæ¦‚è¿°)
- [æŠ€æœ¯æ¶æ„](#æŠ€æœ¯æ¶æ„)
- [æ ¸å¿ƒæ¨¡å—è®¾è®¡](#æ ¸å¿ƒæ¨¡å—è®¾è®¡)
- [API æ¥å£è®¾è®¡](#api-æ¥å£è®¾è®¡)
- [æ™ºèƒ½åŒ¹é…ç®—æ³•](#æ™ºèƒ½åŒ¹é…ç®—æ³•)
- [é”™è¯¯å¤„ç†ä¸å®¹é”™](#é”™è¯¯å¤„ç†ä¸å®¹é”™)
- [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
- [å®‰å…¨è®¾è®¡](#å®‰å…¨è®¾è®¡)

---

## æ–¹æ¡ˆæ¦‚è¿°

### æ ¸å¿ƒé—®é¢˜

å¦‚ä½•ç¡®ä¿**æ•°æ®æµï¼ˆçŸ¥è¯†æ˜Ÿçƒæ‰“å¡ï¼‰** å’Œ **èµ„é‡‘æµï¼ˆå¾®ä¿¡æ”¯ä»˜è®¢å•ï¼‰** çš„ä¸€è‡´æ€§ï¼Ÿ

### è§£å†³æ–¹æ¡ˆ

**æ··åˆæ–¹æ¡ˆ** = SQLite å­˜å‚¨ + æ™ºèƒ½åŒ¹é…ç®—æ³• + äººå·¥å®¡æ ¸

```
ç”¨æˆ·æŠ¥åæ”¯ä»˜ â†’ SQLite å­˜å‚¨æ˜ å°„ â†’ æ‰“å¡å®Œæˆ â†’ æŸ¥è¯¢æ˜ å°„ç”Ÿæˆé€€æ¬¾
                     â†“ å¦‚æœç¼ºå¤±
                 æ™ºèƒ½åŒ¹é…ç®—æ³•è¡¥å……
                     â†“ å¦‚æœä¸ç¡®å®š
                   äººå·¥å®¡æ ¸ç¡®è®¤
```

### æ–¹æ¡ˆä¼˜åŠ¿

| ç‰¹æ€§ | è¯´æ˜ |
|------|------|
| **å‡†ç¡®æ€§** | æ•°æ®åº“è®°å½• 100% å‡†ç¡® |
| **è‡ªåŠ¨åŒ–** | 90%+ è‡ªåŠ¨å¤„ç†ï¼Œæ— éœ€äººå·¥ |
| **å®¹é”™æ€§** | å¤šå±‚å…œåº•æœºåˆ¶ï¼Œæ”¯æŒäººå·¥ä»‹å…¥ |
| **è½»é‡çº§** | ä½¿ç”¨ SQLiteï¼Œæ— éœ€ç‹¬ç«‹æ•°æ®åº“æœåŠ¡ |
| **å¯æ‰©å±•** | æ˜“äºè¿ç§»åˆ° v1 çš„ PostgreSQL |

---

## æŠ€æœ¯æ¶æ„

### ç³»ç»Ÿæ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        H5 å‰ç«¯                               â”‚
â”‚              (Vue 3 + Vite + Element Plus)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“ HTTP/HTTPS
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Express.js API                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ Routes       â”‚ Services     â”‚ Utils                 â”‚    â”‚
â”‚  â”‚ - camps      â”‚ - zsxq       â”‚ - logger              â”‚    â”‚
â”‚  â”‚ - payment    â”‚ - refund     â”‚ - response            â”‚    â”‚
â”‚  â”‚ - refund     â”‚ - payment    â”‚ - sanitize            â”‚    â”‚
â”‚  â”‚              â”‚ - matching   â”‚                       â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   æ•°æ®å±‚ & å¤–éƒ¨ API                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ SQLite       â”‚ çŸ¥è¯†æ˜ŸçƒAPI   â”‚ å¾®ä¿¡æ”¯ä»˜API           â”‚    â”‚
â”‚  â”‚ (æ˜ å°„å­˜å‚¨)   â”‚ (æ‰“å¡æ•°æ®)    â”‚ (äº¤æ˜“è´¦å•)            â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æŠ€æœ¯æ ˆ

| å±‚çº§ | æŠ€æœ¯ | ç‰ˆæœ¬ | è¯´æ˜ |
|------|------|------|------|
| **æ•°æ®åº“** | SQLite 3 | - | è½»é‡çº§å…³ç³»å‹æ•°æ®åº“ |
| **ORM** | better-sqlite3 | ^9.0.0 | é«˜æ€§èƒ½åŒæ­¥ SQLite åº“ |
| **HTTP å®¢æˆ·ç«¯** | axios | ^1.6.0 | è°ƒç”¨å¤–éƒ¨ API |
| **åŠ å¯†/ç­¾å** | crypto (Node.js) | - | å¾®ä¿¡æ”¯ä»˜ç­¾å |
| **æ—¥å¿—** | winston | ^3.11.0 | æ—¥å¿—è®°å½• |
| **æµ‹è¯•** | jest | ^30.2.0 | å•å…ƒæµ‹è¯• & é›†æˆæµ‹è¯• |

### ç›®å½•ç»“æ„

```
zsxq-api/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ payment-mapping.service.js    # æ”¯ä»˜æ˜ å°„å­˜å‚¨
â”‚   â”‚   â”œâ”€â”€ smart-matching.service.js     # æ™ºèƒ½åŒ¹é…ç®—æ³•
â”‚   â”‚   â”œâ”€â”€ wechat-payment.service.js     # å¾®ä¿¡æ”¯ä»˜ API
â”‚   â”‚   â”œâ”€â”€ refund-file.service.js        # é€€æ¬¾æ–‡ä»¶ç”Ÿæˆ
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”œâ”€â”€ payment.js                    # æ”¯ä»˜ç›¸å…³è·¯ç”±
â”‚   â”‚   â””â”€â”€ refund.js                     # é€€æ¬¾ç›¸å…³è·¯ç”±
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ wechat-auth.js                # å¾®ä¿¡æ”¯ä»˜ç­¾å
â”‚   â”‚   â””â”€â”€ csv-generator.js              # CSV æ–‡ä»¶ç”Ÿæˆ
â”‚   â””â”€â”€ db/
â”‚       â”œâ”€â”€ init.js                       # æ•°æ®åº“åˆå§‹åŒ–
â”‚       â””â”€â”€ migrations/                   # æ•°æ®åº“è¿ç§»è„šæœ¬
â”œâ”€â”€ data/
â”‚   â””â”€â”€ payment-mapping.db                # SQLite æ•°æ®åº“æ–‡ä»¶
â”œâ”€â”€ temp/
â”‚   â””â”€â”€ refund-*.csv                      # ä¸´æ—¶ç”Ÿæˆçš„ CSV æ–‡ä»¶
â””â”€â”€ tests/
    â”œâ”€â”€ unit/
    â”‚   â”œâ”€â”€ payment-mapping.test.js
    â”‚   â”œâ”€â”€ smart-matching.test.js
    â”‚   â””â”€â”€ ...
    â””â”€â”€ integration/
        â”œâ”€â”€ refund-flow.test.js
        â””â”€â”€ ...
```

---

## æ ¸å¿ƒæ¨¡å—è®¾è®¡

### 1. æ”¯ä»˜æ˜ å°„å­˜å‚¨æ¨¡å—

**æ–‡ä»¶**: `src/services/payment-mapping.service.js`

```javascript
const Database = require('better-sqlite3');
const logger = require('../utils/logger');

class PaymentMappingService {
  constructor() {
    this.db = new Database('data/payment-mapping.db');
    this.initDatabase();
  }

  /**
   * åˆå§‹åŒ–æ•°æ®åº“è¡¨
   */
  initDatabase() {
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS payment_mapping (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        out_trade_no TEXT UNIQUE NOT NULL,
        transaction_id TEXT,
        planet_user_id TEXT,
        planet_nickname TEXT,
        wechat_nickname TEXT,
        amount INTEGER NOT NULL,
        checkin_id TEXT NOT NULL,
        payment_time TEXT NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      );

      CREATE INDEX IF NOT EXISTS idx_planet_user
        ON payment_mapping(planet_user_id, checkin_id);

      CREATE INDEX IF NOT EXISTS idx_checkin
        ON payment_mapping(checkin_id);

      CREATE INDEX IF NOT EXISTS idx_payment_time
        ON payment_mapping(payment_time);
    `);
  }

  /**
   * ä¿å­˜æ”¯ä»˜æ˜ å°„å…³ç³»
   */
  saveMapping(data) {
    const stmt = this.db.prepare(`
      INSERT INTO payment_mapping
      (out_trade_no, transaction_id, planet_user_id, planet_nickname,
       wechat_nickname, amount, checkin_id, payment_time)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      ON CONFLICT(out_trade_no) DO UPDATE SET
        transaction_id = excluded.transaction_id,
        planet_user_id = excluded.planet_user_id,
        planet_nickname = excluded.planet_nickname,
        wechat_nickname = excluded.wechat_nickname,
        updated_at = CURRENT_TIMESTAMP
    `);

    try {
      const result = stmt.run(
        data.out_trade_no,
        data.transaction_id,
        data.planet_user_id,
        data.planet_nickname,
        data.wechat_nickname,
        data.amount,
        data.checkin_id,
        data.payment_time
      );

      logger.info('æ”¯ä»˜æ˜ å°„ä¿å­˜æˆåŠŸ', {
        out_trade_no: data.out_trade_no,
        planet_user_id: data.planet_user_id
      });

      return result;
    } catch (error) {
      logger.error('æ”¯ä»˜æ˜ å°„ä¿å­˜å¤±è´¥', error);
      throw error;
    }
  }

  /**
   * æ ¹æ®çŸ¥è¯†æ˜Ÿçƒç”¨æˆ·æŸ¥è¯¢æ”¯ä»˜è®°å½•
   */
  getByPlanetUser(planetUserId, checkinId) {
    const stmt = this.db.prepare(`
      SELECT * FROM payment_mapping
      WHERE planet_user_id = ? AND checkin_id = ?
    `);

    return stmt.get(planetUserId, checkinId);
  }

  /**
   * æ ¹æ®è®­ç»ƒè¥ ID æ‰¹é‡æŸ¥è¯¢
   */
  getByCheckin(checkinId) {
    const stmt = this.db.prepare(`
      SELECT * FROM payment_mapping
      WHERE checkin_id = ?
      ORDER BY payment_time DESC
    `);

    return stmt.all(checkinId);
  }

  /**
   * ç»Ÿè®¡æŸä¸ªè®­ç»ƒè¥çš„æ”¯ä»˜è®°å½•æ•°
   */
  countByCheckin(checkinId) {
    const stmt = this.db.prepare(`
      SELECT COUNT(*) as count
      FROM payment_mapping
      WHERE checkin_id = ?
    `);

    return stmt.get(checkinId).count;
  }
}

module.exports = new PaymentMappingService();
```

### 2. å¾®ä¿¡æ”¯ä»˜ API æ¨¡å—

**æ–‡ä»¶**: `src/services/wechat-payment.service.js`

```javascript
const axios = require('axios');
const crypto = require('crypto');
const fs = require('fs');
const logger = require('../utils/logger');

class WechatPaymentService {
  constructor() {
    this.mchid = process.env.WECHAT_PAY_MCHID;
    this.apiKey = process.env.WECHAT_PAY_API_KEY;
    this.serialNo = process.env.WECHAT_PAY_SERIAL_NO;

    // åŠ è½½è¯ä¹¦
    this.privateKey = fs.readFileSync(
      process.env.WECHAT_PAY_KEY_PATH,
      'utf8'
    );
  }

  /**
   * ç”Ÿæˆè¯·æ±‚ç­¾å
   */
  generateSignature(method, url, timestamp, nonce, body = '') {
    const message = `${method}\n${url}\n${timestamp}\n${nonce}\n${body}\n`;

    const sign = crypto.createSign('RSA-SHA256');
    sign.update(message);

    return sign.sign(this.privateKey, 'base64');
  }

  /**
   * ç”Ÿæˆ Authorization å¤´
   */
  generateAuth(method, url, body = '') {
    const timestamp = Math.floor(Date.now() / 1000);
    const nonce = crypto.randomBytes(16).toString('hex');
    const signature = this.generateSignature(
      method,
      url,
      timestamp,
      nonce,
      body
    );

    return `WECHATPAY2-SHA256-RSA2048 ` +
      `mchid="${this.mchid}",` +
      `nonce_str="${nonce}",` +
      `signature="${signature}",` +
      `timestamp="${timestamp}",` +
      `serial_no="${this.serialNo}"`;
  }

  /**
   * ä¸‹è½½äº¤æ˜“è´¦å•
   */
  async getTradeBill(billDate, billType = 'ALL') {
    const url = '/v3/bill/tradebill';
    const fullUrl = `https://api.mch.weixin.qq.com${url}`;

    try {
      // 1. è·å–è´¦å•ä¸‹è½½é“¾æ¥
      const response = await axios.get(fullUrl, {
        params: {
          bill_date: billDate,
          bill_type: billType
        },
        headers: {
          'Authorization': this.generateAuth('GET', url),
          'Accept': 'application/json'
        }
      });

      const downloadUrl = response.data.download_url;

      // 2. ä¸‹è½½è´¦å•æ–‡ä»¶
      const billData = await axios.get(downloadUrl, {
        headers: {
          'Authorization': this.generateAuth('GET', downloadUrl)
        }
      });

      logger.info('äº¤æ˜“è´¦å•ä¸‹è½½æˆåŠŸ', { billDate, billType });

      // 3. è§£æ CSV æ•°æ®
      return this.parseBillData(billData.data);
    } catch (error) {
      logger.error('äº¤æ˜“è´¦å•ä¸‹è½½å¤±è´¥', error);
      throw error;
    }
  }

  /**
   * è§£æè´¦å• CSV æ•°æ®
   */
  parseBillData(csvData) {
    const lines = csvData.split('\n');
    const payments = [];

    // è·³è¿‡å‰å‡ è¡Œçš„è¯´æ˜æ–‡å­—
    let dataStartIndex = 0;
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].startsWith('äº¤æ˜“æ—¶é—´')) {
        dataStartIndex = i + 1;
        break;
      }
    }

    // è§£ææ•°æ®è¡Œ
    for (let i = dataStartIndex; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line || line.startsWith('æ€»äº¤æ˜“å•æ•°')) break;

      const fields = line.split(',').map(f => f.trim().replace(/`/g, ''));

      if (fields.length >= 10) {
        payments.push({
          payment_time: fields[0],
          out_trade_no: fields[2],
          transaction_id: fields[3],
          payer_name: fields[8],
          amount: parseFloat(fields[9]),
          trade_state: fields[4]
        });
      }
    }

    return payments;
  }

  /**
   * æŸ¥è¯¢å•ç¬”è®¢å•
   */
  async queryOrder(outTradeNo) {
    const url = `/v3/pay/transactions/out-trade-no/${outTradeNo}`;
    const fullUrl = `https://api.mch.weixin.qq.com${url}`;

    try {
      const response = await axios.get(fullUrl, {
        params: {
          mchid: this.mchid
        },
        headers: {
          'Authorization': this.generateAuth('GET', url),
          'Accept': 'application/json'
        }
      });

      return response.data;
    } catch (error) {
      logger.error('è®¢å•æŸ¥è¯¢å¤±è´¥', { outTradeNo, error });
      throw error;
    }
  }
}

module.exports = new WechatPaymentService();
```

### 3. æ™ºèƒ½åŒ¹é…ç®—æ³•æ¨¡å—

**æ–‡ä»¶**: `src/services/smart-matching.service.js`

```javascript
const logger = require('../utils/logger');
const wechatPaymentService = require('./wechat-payment.service');

class SmartMatchingService {
  /**
   * æ™ºèƒ½åŒ¹é…ï¼šçŸ¥è¯†æ˜Ÿçƒç”¨æˆ· â†’ å¾®ä¿¡æ”¯ä»˜è®¢å•
   */
  async matchUsers(users, checkinId) {
    // 1. è·å–è®­ç»ƒè¥å¼€å§‹æ—¥æœŸçš„è´¦å•
    const billDate = this.getCheckinStartDate(checkinId);
    const payments = await wechatPaymentService.getTradeBill(billDate);

    // 2. è¿‡æ»¤å‡ºæœ¬è®­ç»ƒè¥çš„è®¢å•ï¼ˆæ ¹æ®é‡‘é¢ï¼‰
    const checkinAmount = this.getCheckinAmount(checkinId);
    const filteredPayments = payments.filter(p =>
      p.amount === checkinAmount &&
      p.trade_state === 'SUCCESS'
    );

    logger.info('å¯ç”¨æ”¯ä»˜è®°å½•', {
      total: payments.length,
      filtered: filteredPayments.length
    });

    // 3. é€ä¸ªç”¨æˆ·è¿›è¡ŒåŒ¹é…
    const matched = [];
    const unmatched = [];

    for (const user of users) {
      const result = this.findBestMatch(user, filteredPayments);

      if (result && result.confidence >= 50) {
        matched.push({
          ...user,
          ...result,
          match_method: 'smart_matching'
        });
      } else {
        unmatched.push(user);
      }
    }

    return { matched, unmatched };
  }

  /**
   * ä¸ºå•ä¸ªç”¨æˆ·æ‰¾åˆ°æœ€ä½³åŒ¹é…
   */
  findBestMatch(user, payments) {
    let bestMatch = null;
    let highestScore = 0;

    for (const payment of payments) {
      const score = this.calculateMatchScore(user, payment);

      if (score > highestScore) {
        highestScore = score;
        bestMatch = {
          out_trade_no: payment.out_trade_no,
          transaction_id: payment.transaction_id,
          amount: payment.amount,
          payment_time: payment.payment_time,
          confidence: score,
          payer_name: payment.payer_name
        };
      }
    }

    return highestScore >= 50 ? bestMatch : null;
  }

  /**
   * è®¡ç®—åŒ¹é…è¯„åˆ†ï¼ˆ0-100ï¼‰
   */
  calculateMatchScore(user, payment) {
    let score = 0;

    // 1. æ˜µç§°åŒ¹é…ï¼ˆæƒé‡ 60%ï¼‰
    const nicknameScore = this.compareNicknames(
      user.planet_nickname,
      payment.payer_name
    );
    score += nicknameScore * 0.6;

    // 2. æ—¶é—´åŒ¹é…ï¼ˆæƒé‡ 20%ï¼‰
    const timeScore = this.compareTime(
      user.join_time,
      payment.payment_time
    );
    score += timeScore * 0.2;

    // 3. é‡‘é¢åŒ¹é…ï¼ˆæƒé‡ 20%ï¼‰
    const amountScore = this.compareAmount(
      this.getCheckinAmount(user.checkin_id),
      payment.amount
    );
    score += amountScore * 0.2;

    return Math.round(score);
  }

  /**
   * æ˜µç§°ç›¸ä¼¼åº¦æ¯”è¾ƒï¼ˆ0-100ï¼‰
   */
  compareNicknames(nickname1, nickname2) {
    if (!nickname1 || !nickname2) return 0;

    // å®Œå…¨åŒ¹é…
    if (nickname1 === nickname2) return 100;

    // åŒ…å«å…³ç³»
    if (nickname1.includes(nickname2) || nickname2.includes(nickname1)) {
      return 80;
    }

    // ç§»é™¤ç©ºæ ¼åæ¯”è¾ƒ
    const clean1 = nickname1.replace(/\s/g, '');
    const clean2 = nickname2.replace(/\s/g, '');

    if (clean1 === clean2) return 90;
    if (clean1.includes(clean2) || clean2.includes(clean1)) {
      return 70;
    }

    // Levenshtein è·ç¦»ç®—æ³•
    const distance = this.levenshteinDistance(clean1, clean2);
    const maxLen = Math.max(clean1.length, clean2.length);
    const similarity = (1 - distance / maxLen) * 100;

    return Math.max(0, Math.round(similarity));
  }

  /**
   * Levenshtein è·ç¦»ç®—æ³•
   */
  levenshteinDistance(str1, str2) {
    const matrix = [];

    for (let i = 0; i <= str2.length; i++) {
      matrix[i] = [i];
    }

    for (let j = 0; j <= str1.length; j++) {
      matrix[0][j] = j;
    }

    for (let i = 1; i <= str2.length; i++) {
      for (let j = 1; j <= str1.length; j++) {
        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          );
        }
      }
    }

    return matrix[str2.length][str1.length];
  }

  /**
   * æ—¶é—´ç›¸ä¼¼åº¦æ¯”è¾ƒï¼ˆ0-100ï¼‰
   */
  compareTime(joinTime, paymentTime) {
    if (!joinTime || !paymentTime) return 50;  // é»˜è®¤åˆ†æ•°

    const join = new Date(joinTime);
    const payment = new Date(paymentTime);

    const diffHours = Math.abs(join - payment) / (1000 * 60 * 60);

    // æ”¯ä»˜æ—¶é—´åº”è¯¥åœ¨åŠ å…¥æ—¶é—´å‰å 24 å°æ—¶å†…
    if (diffHours <= 1) return 100;
    if (diffHours <= 6) return 80;
    if (diffHours <= 24) return 60;
    if (diffHours <= 72) return 40;

    return 0;
  }

  /**
   * é‡‘é¢åŒ¹é…ï¼ˆ0-100ï¼‰
   */
  compareAmount(expectedAmount, actualAmount) {
    return expectedAmount === actualAmount ? 100 : 0;
  }

  /**
   * è·å–è®­ç»ƒè¥å¼€å§‹æ—¥æœŸ
   */
  getCheckinStartDate(checkinId) {
    // TODO: ä»çŸ¥è¯†æ˜Ÿçƒ API è·å–è®­ç»ƒè¥å¼€å§‹æ—¶é—´
    // è¿™é‡Œæš‚æ—¶è¿”å›å½“å‰æ—¥æœŸ
    return new Date().toISOString().split('T')[0];
  }

  /**
   * è·å–è®­ç»ƒè¥æŠ¼é‡‘é‡‘é¢
   */
  getCheckinAmount(checkinId) {
    // TODO: ä»é…ç½®æˆ– API è·å–
    return 99.00;  // é»˜è®¤ 99 å…ƒ
  }
}

module.exports = new SmartMatchingService();
```

### 4. é€€æ¬¾æ–‡ä»¶ç”Ÿæˆæ¨¡å—

**æ–‡ä»¶**: `src/services/refund-file.service.js`

```javascript
const path = require('path');
const fs = require('fs');
const logger = require('../utils/logger');
const refundService = require('./refund.service');
const paymentMappingService = require('./payment-mapping.service');
const smartMatchingService = require('./smart-matching.service');

class RefundFileService {
  /**
   * ç”Ÿæˆé€€æ¬¾æ–‡ä»¶ï¼ˆä¸»å…¥å£ï¼‰
   */
  async generateRefundFile(checkinId, requiredDays) {
    logger.info('å¼€å§‹ç”Ÿæˆé€€æ¬¾æ–‡ä»¶', { checkinId, requiredDays });

    // 1. ä»çŸ¥è¯†æ˜Ÿçƒè·å–åˆæ ¼ç”¨æˆ·åˆ—è¡¨
    const refundList = await refundService.generateRefundList(
      checkinId,
      requiredDays
    );

    const qualifiedUsers = refundList.refund_list.filter(
      u => u.is_qualified
    );

    // 2. å°è¯•ä»æ•°æ®åº“åŒ¹é…
    const { dbMatched, dbUnmatched } = await this.matchFromDatabase(
      qualifiedUsers,
      checkinId
    );

    // 3. å¯¹æœªåŒ¹é…çš„ç”¨æˆ·ï¼Œå°è¯•æ™ºèƒ½åŒ¹é…
    let aiMatched = [];
    if (dbUnmatched.length > 0) {
      const result = await smartMatchingService.matchUsers(
        dbUnmatched,
        checkinId
      );
      aiMatched = result.matched;
    }

    // 4. åˆ†ç±»ç»“æœ
    const allMatched = [...dbMatched, ...aiMatched];
    const needReview = aiMatched.filter(m => m.confidence < 80);
    const autoApproved = allMatched.filter(m => m.confidence >= 80);
    const failed = qualifiedUsers.filter(
      u => !allMatched.find(m => m.planet_user_id === u.planet_user_id)
    );

    // 5. ç”Ÿæˆ CSV æ–‡ä»¶
    const csvContent = this.generateCSV(autoApproved);
    const filename = `refund_${checkinId}_${Date.now()}.csv`;
    const filepath = path.join(__dirname, '../../temp', filename);

    // ç¡®ä¿ temp ç›®å½•å­˜åœ¨
    if (!fs.existsSync(path.dirname(filepath))) {
      fs.mkdirSync(path.dirname(filepath), { recursive: true });
    }

    fs.writeFileSync(filepath, csvContent, 'utf8');

    logger.info('é€€æ¬¾æ–‡ä»¶ç”ŸæˆæˆåŠŸ', {
      filename,
      total: qualifiedUsers.length,
      auto_matched: dbMatched.length,
      ai_matched: aiMatched.length,
      need_review: needReview.length,
      failed: failed.length
    });

    // 6. è¿”å›ç»“æœ
    return {
      csv_filename: filename,
      csv_url: `/downloads/${filename}`,
      statistics: {
        total_qualified: qualifiedUsers.length,
        auto_matched: dbMatched.length,
        ai_matched: aiMatched.length,
        need_manual_review: needReview.length,
        failed: failed.length
      },
      need_review: needReview.map(m => ({
        planet_user_id: m.planet_user_id,
        planet_nickname: m.planet_nickname,
        out_trade_no: m.out_trade_no,
        payer_name: m.payer_name,
        confidence: m.confidence,
        reason: this.getMatchReason(m.confidence)
      })),
      failed: failed.map(u => ({
        planet_user_id: u.planet_user_id,
        planet_nickname: u.planet_nickname,
        reason: 'æœªæ‰¾åˆ°åŒ¹é…çš„æ”¯ä»˜è®°å½•'
      }))
    };
  }

  /**
   * ä»æ•°æ®åº“åŒ¹é…
   */
  async matchFromDatabase(users, checkinId) {
    const dbMatched = [];
    const dbUnmatched = [];

    for (const user of users) {
      const payment = paymentMappingService.getByPlanetUser(
        user.planet_user_id,
        checkinId
      );

      if (payment) {
        dbMatched.push({
          ...user,
          out_trade_no: payment.out_trade_no,
          transaction_id: payment.transaction_id,
          amount: payment.amount / 100,  // åˆ† â†’ å…ƒ
          confidence: 100,
          match_method: 'database'
        });
      } else {
        dbUnmatched.push(user);
      }
    }

    return { dbMatched, dbUnmatched };
  }

  /**
   * ç”Ÿæˆ CSV å†…å®¹
   */
  generateCSV(matchedList) {
    let csv = '';

    for (const item of matchedList) {
      const refundNo = `REFUND_${item.out_trade_no}`;
      const reason = 'å®Œæˆæ‰“å¡';

      // æ ¼å¼ï¼šå•†æˆ·è®¢å•å·,é€€æ¬¾é‡‘é¢,é€€æ¬¾åŸå› ,å•†æˆ·é€€æ¬¾å•å·
      csv += `${item.out_trade_no},${item.amount.toFixed(2)},${reason},${refundNo}\n`;
    }

    return csv;
  }

  /**
   * è·å–åŒ¹é…åŸå› è¯´æ˜
   */
  getMatchReason(confidence) {
    if (confidence >= 80) return 'AI é«˜ç½®ä¿¡åº¦åŒ¹é…';
    if (confidence >= 60) return 'æ˜µç§°éƒ¨åˆ†åŒ¹é…';
    if (confidence >= 50) return 'ä½ç½®ä¿¡åº¦åŒ¹é…';
    return 'æ— æ³•åŒ¹é…';
  }
}

module.exports = new RefundFileService();
```

---

## API æ¥å£è®¾è®¡

### è·¯ç”±å®šä¹‰

**æ–‡ä»¶**: `src/routes/refund.js`

```javascript
const express = require('express');
const router = express.Router();
const refundFileService = require('../services/refund-file.service');
const { success, error } = require('../utils/response');
const logger = require('../utils/logger');

/**
 * @swagger
 * /api/camps/{checkinId}/refund-file:
 *   post:
 *     summary: ç”Ÿæˆé€€æ¬¾æ–‡ä»¶
 *     tags: [é€€æ¬¾ç®¡ç†]
 *     parameters:
 *       - in: path
 *         name: checkinId
 *         required: true
 *         schema:
 *           type: string
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               required_days:
 *                 type: integer
 *                 description: å®Œæˆè¦æ±‚å¤©æ•°
 *                 example: 7
 *     responses:
 *       200:
 *         description: é€€æ¬¾æ–‡ä»¶ç”ŸæˆæˆåŠŸ
 */
router.post('/:checkinId/refund-file', async (req, res, next) => {
  try {
    const { checkinId } = req.params;
    const { required_days } = req.body;

    // å‚æ•°æ ¡éªŒ
    if (!checkinId) {
      return res.status(400).json(error('è®­ç»ƒè¥ ID ä¸èƒ½ä¸ºç©º', 400));
    }

    if (!required_days || required_days < 1) {
      return res.status(400).json(error('å®Œæˆè¦æ±‚å¤©æ•°å¿…é¡»å¤§äº 0', 400));
    }

    // ç”Ÿæˆé€€æ¬¾æ–‡ä»¶
    const result = await refundFileService.generateRefundFile(
      checkinId,
      required_days
    );

    res.json(success(result, 'é€€æ¬¾æ–‡ä»¶ç”ŸæˆæˆåŠŸ'));
  } catch (err) {
    logger.error('ç”Ÿæˆé€€æ¬¾æ–‡ä»¶å¤±è´¥', err);
    next(err);
  }
});

/**
 * @swagger
 * /api/refund/review:
 *   post:
 *     summary: äººå·¥å®¡æ ¸ç¡®è®¤åŒ¹é…
 *     tags: [é€€æ¬¾ç®¡ç†]
 */
router.post('/review', async (req, res, next) => {
  try {
    const { planet_user_id, out_trade_no, action } = req.body;

    // TODO: å®ç°äººå·¥å®¡æ ¸é€»è¾‘
    // 1. ä¿å­˜å®¡æ ¸ç»“æœåˆ°æ•°æ®åº“
    // 2. å¦‚æœé€šè¿‡ï¼Œæ›´æ–°åŒ¹é…å…³ç³»
    // 3. å¦‚æœæ‹’ç»ï¼Œæ ‡è®°ä¸ºéœ€äººå·¥å¤„ç†

    res.json(success({ action }, 'å®¡æ ¸æˆåŠŸ'));
  } catch (err) {
    logger.error('å®¡æ ¸å¤±è´¥', err);
    next(err);
  }
});

module.exports = router;
```

**æ–‡ä»¶**: `src/routes/payment.js`

```javascript
const express = require('express');
const router = express.Router();
const paymentMappingService = require('../services/payment-mapping.service');
const { success, error } = require('../utils/response');
const logger = require('../utils/logger');

/**
 * @swagger
 * /api/payment/mapping:
 *   post:
 *     summary: ä¿å­˜æ”¯ä»˜æ˜ å°„å…³ç³»
 *     tags: [æ”¯ä»˜ç®¡ç†]
 */
router.post('/mapping', async (req, res, next) => {
  try {
    const data = req.body;

    // å‚æ•°æ ¡éªŒ
    if (!data.out_trade_no || !data.checkin_id || !data.amount) {
      return res.status(400).json(error('ç¼ºå°‘å¿…éœ€å‚æ•°', 400));
    }

    // ä¿å­˜æ˜ å°„
    paymentMappingService.saveMapping(data);

    res.json(success({}, 'æ”¯ä»˜æ˜ å°„ä¿å­˜æˆåŠŸ'));
  } catch (err) {
    logger.error('ä¿å­˜æ”¯ä»˜æ˜ å°„å¤±è´¥', err);
    next(err);
  }
});

/**
 * @swagger
 * /api/payment/webhook:
 *   post:
 *     summary: å¾®ä¿¡æ”¯ä»˜å›è°ƒ
 *     tags: [æ”¯ä»˜ç®¡ç†]
 */
router.post('/webhook', async (req, res, next) => {
  try {
    // TODO: å®ç°å¾®ä¿¡æ”¯ä»˜å›è°ƒå¤„ç†
    // 1. éªŒè¯ç­¾å
    // 2. è§£ææ”¯ä»˜ç»“æœ
    // 3. ä¿å­˜æ”¯ä»˜æ˜ å°„
    // 4. è¿”å›ç¾¤äºŒç»´ç 

    res.json({ code: 'SUCCESS', message: 'æˆåŠŸ' });
  } catch (err) {
    logger.error('æ”¯ä»˜å›è°ƒå¤„ç†å¤±è´¥', err);
    res.json({ code: 'FAIL', message: 'å¤±è´¥' });
  }
});

module.exports = router;
```

### ä¸‹è½½æ–‡ä»¶è·¯ç”±

**æ–‡ä»¶**: `src/routes/downloads.js`

```javascript
const express = require('express');
const router = express.Router();
const path = require('path');
const logger = require('../utils/logger');

/**
 * ä¸‹è½½é€€æ¬¾ CSV æ–‡ä»¶
 */
router.get('/:filename', (req, res) => {
  const filename = req.params.filename;

  // å®‰å…¨æ£€æŸ¥ï¼šé˜²æ­¢è·¯å¾„ç©¿è¶Šæ”»å‡»
  if (filename.includes('..') || filename.includes('/')) {
    return res.status(400).send('éæ³•æ–‡ä»¶å');
  }

  const filepath = path.join(__dirname, '../../temp', filename);

  logger.info('ä¸‹è½½é€€æ¬¾æ–‡ä»¶', { filename });

  res.download(filepath, (err) => {
    if (err) {
      logger.error('æ–‡ä»¶ä¸‹è½½å¤±è´¥', err);
      res.status(404).send('æ–‡ä»¶ä¸å­˜åœ¨');
    }
  });
});

module.exports = router;
```

---

## æ™ºèƒ½åŒ¹é…ç®—æ³•

### ç®—æ³•æµç¨‹

```
è¾“å…¥: çŸ¥è¯†æ˜Ÿçƒç”¨æˆ·åˆ—è¡¨ + å¾®ä¿¡æ”¯ä»˜è®¢å•åˆ—è¡¨

FOR EACH ç”¨æˆ· IN ç”¨æˆ·åˆ—è¡¨:
    bestMatch = null
    highestScore = 0

    FOR EACH è®¢å• IN è®¢å•åˆ—è¡¨:
        score = 0

        # 1. æ˜µç§°åŒ¹é… (60%)
        nicknameScore = CompareNicknames(ç”¨æˆ·æ˜µç§°, ä»˜æ¬¾äººæ˜µç§°)
        score += nicknameScore * 0.6

        # 2. æ—¶é—´åŒ¹é… (20%)
        timeScore = CompareTime(åŠ å…¥æ—¶é—´, æ”¯ä»˜æ—¶é—´)
        score += timeScore * 0.2

        # 3. é‡‘é¢åŒ¹é… (20%)
        amountScore = CompareAmount(æŠ¼é‡‘é‡‘é¢, æ”¯ä»˜é‡‘é¢)
        score += amountScore * 0.2

        IF score > highestScore:
            highestScore = score
            bestMatch = è®¢å•

    IF highestScore >= 50:
        åŒ¹é…æˆåŠŸ, ç½®ä¿¡åº¦ = highestScore
    ELSE:
        åŒ¹é…å¤±è´¥

è¾“å‡º: { åŒ¹é…åˆ—è¡¨, æœªåŒ¹é…åˆ—è¡¨ }
```

### æ˜µç§°ç›¸ä¼¼åº¦ç®—æ³•

ä½¿ç”¨ **Levenshtein è·ç¦»ç®—æ³•** è®¡ç®—ä¸¤ä¸ªå­—ç¬¦ä¸²çš„ç›¸ä¼¼åº¦ï¼š

```javascript
function levenshteinDistance(str1, str2) {
  const matrix = [];

  // åˆå§‹åŒ–çŸ©é˜µ
  for (let i = 0; i <= str2.length; i++) {
    matrix[i] = [i];
  }
  for (let j = 0; j <= str1.length; j++) {
    matrix[0][j] = j;
  }

  // åŠ¨æ€è§„åˆ’å¡«å……çŸ©é˜µ
  for (let i = 1; i <= str2.length; i++) {
    for (let j = 1; j <= str1.length; j++) {
      if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(
          matrix[i - 1][j - 1] + 1,  // æ›¿æ¢
          matrix[i][j - 1] + 1,      // æ’å…¥
          matrix[i - 1][j] + 1       // åˆ é™¤
        );
      }
    }
  }

  return matrix[str2.length][str1.length];
}

// ç›¸ä¼¼åº¦ = 1 - (è·ç¦» / æœ€å¤§é•¿åº¦)
function similarity(str1, str2) {
  const distance = levenshteinDistance(str1, str2);
  const maxLen = Math.max(str1.length, str2.length);
  return (1 - distance / maxLen) * 100;
}
```

**ç¤ºä¾‹**ï¼š

| str1 | str2 | è·ç¦» | ç›¸ä¼¼åº¦ |
|------|------|------|--------|
| çƒçƒ | çƒçƒ | 0 | 100% |
| çƒçƒçš„å‰¯ä¸šæ¢ç´¢è·¯ | çƒçƒ | 6 | 33% |
| å°æ˜åŒå­¦ | å°æ˜ | 2 | 50% |
| Aaron | Aaron.Wang | 5 | 54% |

---

## é”™è¯¯å¤„ç†ä¸å®¹é”™

### é”™è¯¯åˆ†ç±»

| é”™è¯¯ç±»å‹ | å¤„ç†ç­–ç•¥ | ç”¨æˆ·æç¤º |
|---------|---------|---------|
| æ•°æ®åº“é”™è¯¯ | é‡è¯• 3 æ¬¡ï¼Œå¤±è´¥åˆ™é™çº§åˆ°åªè¯»æ¨¡å¼ | "ç³»ç»Ÿç¹å¿™ï¼Œè¯·ç¨åé‡è¯•" |
| çŸ¥è¯†æ˜Ÿçƒ API å¤±è´¥ | é‡è¯• 2 æ¬¡ï¼Œå¤±è´¥åˆ™è¿”å›é”™è¯¯ | "çŸ¥è¯†æ˜ŸçƒAPIå¼‚å¸¸" |
| å¾®ä¿¡æ”¯ä»˜ API å¤±è´¥ | é™çº§åˆ°äººå·¥åŒ¹é… | "è‡ªåŠ¨åŒ¹é…å¤±è´¥ï¼Œè¯·äººå·¥å®¡æ ¸" |
| æ–‡ä»¶ç”Ÿæˆå¤±è´¥ | é‡è¯• 1 æ¬¡ï¼Œè®°å½•æ—¥å¿— | "æ–‡ä»¶ç”Ÿæˆå¤±è´¥" |
| å‚æ•°æ ¡éªŒå¤±è´¥ | ç«‹å³è¿”å› 400 é”™è¯¯ | å…·ä½“å‚æ•°é”™è¯¯ä¿¡æ¯ |

### å®¹é”™æœºåˆ¶

```javascript
// é€šç”¨é‡è¯•å‡½æ•°
async function retryAsync(fn, maxRetries = 3, delay = 1000) {
  let lastError;

  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      logger.warn(`é‡è¯• ${i + 1}/${maxRetries}`, error);

      if (i < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }

  throw lastError;
}

// ä½¿ç”¨ç¤ºä¾‹
const payments = await retryAsync(
  () => wechatPaymentService.getTradeBill(billDate),
  3,
  2000
);
```

---

## æ€§èƒ½ä¼˜åŒ–

### 1. æ•°æ®åº“ç´¢å¼•ä¼˜åŒ–

```sql
-- ä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½
CREATE INDEX idx_planet_user ON payment_mapping(planet_user_id, checkin_id);
CREATE INDEX idx_checkin ON payment_mapping(checkin_id);
CREATE INDEX idx_payment_time ON payment_mapping(payment_time);
```

### 2. æ‰¹é‡æŸ¥è¯¢ä¼˜åŒ–

```javascript
// âŒ ä¸å¥½çš„åšæ³•ï¼šN+1 æŸ¥è¯¢
for (const user of users) {
  const payment = db.prepare('SELECT * FROM payment_mapping WHERE planet_user_id = ?')
    .get(user.planet_user_id);
}

// âœ… å¥½çš„åšæ³•ï¼šæ‰¹é‡æŸ¥è¯¢
const userIds = users.map(u => u.planet_user_id);
const payments = db.prepare(`
  SELECT * FROM payment_mapping
  WHERE planet_user_id IN (${userIds.map(() => '?').join(',')})
`).all(...userIds);
```

### 3. å¹¶å‘å¤„ç†ä¼˜åŒ–

```javascript
const pLimit = require('p-limit');
const limit = pLimit(10);  // æœ€å¤š 10 ä¸ªå¹¶å‘

// å¹¶å‘å¤„ç†å¤šä¸ªç”¨æˆ·åŒ¹é…
const promises = users.map(user =>
  limit(() => smartMatchingService.findBestMatch(user, payments))
);

const results = await Promise.all(promises);
```

### 4. ç¼“å­˜ä¼˜åŒ–

```javascript
// ç¼“å­˜è®­ç»ƒè¥ä¿¡æ¯ï¼ˆé¿å…é‡å¤æŸ¥è¯¢ï¼‰
const checkinCache = new Map();

function getCheckinAmount(checkinId) {
  if (checkinCache.has(checkinId)) {
    return checkinCache.get(checkinId);
  }

  const amount = fetchCheckinAmount(checkinId);  // ä» API è·å–
  checkinCache.set(checkinId, amount);
  return amount;
}
```

---

## å®‰å…¨è®¾è®¡

### 1. å¾®ä¿¡æ”¯ä»˜ç­¾åéªŒè¯

```javascript
function verifySignature(timestamp, nonce, body, signature) {
  const message = `${timestamp}\n${nonce}\n${body}\n`;

  const verify = crypto.createVerify('RSA-SHA256');
  verify.update(message);

  return verify.verify(wechatPublicKey, signature, 'base64');
}
```

### 2. é˜²æ­¢ SQL æ³¨å…¥

```javascript
// âœ… ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢
const stmt = db.prepare('SELECT * FROM payment_mapping WHERE planet_user_id = ?');
stmt.get(planetUserId);

// âŒ æ°¸è¿œä¸è¦æ‹¼æ¥ SQL
// const sql = `SELECT * FROM payment_mapping WHERE planet_user_id = '${planetUserId}'`;
```

### 3. æ–‡ä»¶ä¸‹è½½è·¯å¾„å®‰å…¨

```javascript
// é˜²æ­¢è·¯å¾„ç©¿è¶Šæ”»å‡»
function sanitizeFilename(filename) {
  if (filename.includes('..') || filename.includes('/')) {
    throw new Error('éæ³•æ–‡ä»¶å');
  }
  return filename;
}
```

### 4. æ•æ„Ÿæ•°æ®è„±æ•

```javascript
// æ—¥å¿—ä¸­è„±æ•å¤„ç†
function maskSensitiveData(data) {
  return {
    ...data,
    transaction_id: data.transaction_id?.replace(/(.{6})(.*)(.{4})/, '$1****$3'),
    out_trade_no: data.out_trade_no?.replace(/(.{6})(.*)(.{4})/, '$1****$3')
  };
}

logger.info('æ”¯ä»˜æ˜ å°„ä¿å­˜', maskSensitiveData(data));
```

---

## æµ‹è¯•ç­–ç•¥

### å•å…ƒæµ‹è¯•

```javascript
// tests/unit/smart-matching.test.js
describe('SmartMatchingService', () => {
  test('æ˜µç§°å®Œå…¨åŒ¹é…åº”è¿”å› 100 åˆ†', () => {
    const score = service.compareNicknames('çƒçƒ', 'çƒçƒ');
    expect(score).toBe(100);
  });

  test('æ˜µç§°åŒ…å«å…³ç³»åº”è¿”å› 80 åˆ†', () => {
    const score = service.compareNicknames('çƒçƒçš„å‰¯ä¸šæ¢ç´¢è·¯', 'çƒçƒ');
    expect(score).toBe(80);
  });

  test('å®Œå…¨ä¸åŒ¹é…åº”è¿”å›ä½åˆ†', () => {
    const score = service.compareNicknames('å¼ ä¸‰', 'æå››');
    expect(score).toBeLessThan(30);
  });
});
```

### é›†æˆæµ‹è¯•

```javascript
// tests/integration/refund-flow.test.js
describe('é€€æ¬¾æµç¨‹é›†æˆæµ‹è¯•', () => {
  test('å®Œæ•´æµç¨‹ï¼šä»ä¿å­˜æ˜ å°„åˆ°ç”Ÿæˆé€€æ¬¾æ–‡ä»¶', async () => {
    // 1. ä¿å­˜æ”¯ä»˜æ˜ å°„
    await paymentMappingService.saveMapping({
      out_trade_no: 'TEST_ORDER_001',
      planet_user_id: '88455815452182',
      // ...
    });

    // 2. ç”Ÿæˆé€€æ¬¾æ–‡ä»¶
    const result = await refundFileService.generateRefundFile(
      '842448118',
      7
    );

    // 3. éªŒè¯ç»“æœ
    expect(result.statistics.auto_matched).toBeGreaterThan(0);
    expect(result.csv_filename).toMatch(/^refund_.*\.csv$/);
  });
});
```

---

## ç›¸å…³æ–‡æ¡£

- [README.md](./README.md) - v0.2 ç‰ˆæœ¬æ¦‚è¿°
- [ç”¨æˆ·æ—…ç¨‹å›¾.md](./ç”¨æˆ·æ—…ç¨‹å›¾.md) - å®Œæ•´çš„ç”¨æˆ·æµç¨‹å›¾
- [æ•°æ®åº“è®¾è®¡.md](./æ•°æ®åº“è®¾è®¡.md) - SQLite è¡¨ç»“æ„è®¾è®¡